#ifndef LaserTherm_Configuration_ptree_utils_hpp
#define LaserTherm_Configuration_ptree_utils_hpp

/** @file ptree_utils.hpp
 * @brief
 * @author C.D. Clark III
 * @date 03/28/19
 */

#include <algorithm>

#include <boost/lexical_cast.hpp>
#include <boost/property_tree/ptree.hpp>

#include <UnitConvert.hpp>

namespace
{
namespace bpt = boost::property_tree;
}

/** the boost translator from string to int fails if the string contains a
decimal point. so "1.0" will not translate to 1. our config files will often
have a float value for int parameters, especially if they where generated by the
repGen.py program, so we want to allow floats to be translated to ints. we just
need to supply a special translator for this.
 */
struct intTranslator {
  typedef std::string            internal_type;
  typedef int                    external_type;
  boost::optional<external_type> get_value(const internal_type& str)
  {
    if (str.empty())
      return boost::optional<external_type>(boost::none);
    else
      return boost::optional<external_type>(
          static_cast<external_type>(boost::lexical_cast<float>(str)));
  }

  boost::optional<internal_type> put_value(const external_type& val)
  {
    return boost::optional<internal_type>(
        boost::lexical_cast<std::string>(val));
  }
};
namespace boost
{
namespace property_tree
{
template<typename Ch, typename Traits, typename Alloc>
struct translator_between<std::basic_string<Ch, Traits, Alloc>, int> {
  typedef intTranslator type;
};
}  // namespace property_tree
}  // namespace boost

/**
 * Converts all quantities in a property tree to values expressed
 * in the base units of a unit registry.
 */
void convertPropertyTreeUnits(bpt::ptree& config, const UnitRegistry& ureg);
std::vector<bpt::ptree::path_type> get_paths(const bpt::ptree& tree,
                                             char              delim = '.');
/**
 * Return a flattened version of the property tree.
 * All nodes are a direct child of the root/top of the tree.
 */
bpt::ptree flatten_ptree(const bpt::ptree& tree, char delim = '.');

/**
 * Return an un-flattened version of the property tree. Nodes that contain the
 * delimiter in their name will be split into a node with a child node.
 *
 * @param odelim the output delimiter. the character that will be used to
 * determine the new nesting level of each node.
 * @param idelim the input delimiter. the character that is used to delimit
 * levels in the input tree.
 *
 */
bpt::ptree unflatten_ptree(const bpt::ptree& ftree, char odelim = '.',
                           char idelim = '.');

#endif  // include protector
