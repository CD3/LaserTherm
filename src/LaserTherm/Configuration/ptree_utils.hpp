#ifndef LaserTherm_Configuration_ptree_utils_hpp
#define LaserTherm_Configuration_ptree_utils_hpp

/** @file ptree_utils.hpp
 * @brief
 * @author C.D. Clark III
 * @date 03/28/19
 */

#include <algorithm>

#include <boost/lexical_cast.hpp>
#include <boost/property_tree/ptree.hpp>

#include <UnitConvert.hpp>

namespace
{
namespace bpt = boost::property_tree;
}

/** the boost translator from string to int fails if the string contains a
decimal point. so "1.0" will not translate to 1. our config files will often
have a float value for int parameters, especially if they where generated by the
repGen.py program, so we want to allow floats to be translated to ints. we just
need to supply a special translator for this.
 */
struct intTranslator {
  typedef std::string            internal_type;
  typedef int                    external_type;
  boost::optional<external_type> get_value(const internal_type& str)
  {
    if (str.empty())
      return boost::optional<external_type>(boost::none);
    else
      return boost::optional<external_type>(
          static_cast<external_type>( boost::lexical_cast<float>(str)) );
  }

  boost::optional<internal_type> put_value(const external_type& val)
  {
    return boost::optional<internal_type>(
        boost::lexical_cast<std::string>(val));
  }
};
namespace boost
{
namespace property_tree
{
template<typename Ch, typename Traits, typename Alloc>
struct translator_between<std::basic_string<Ch, Traits, Alloc>, int> {
  typedef intTranslator type;
};
}  // namespace property_tree
}  // namespace boost

/**
 * Converts all quantities in a property tree to values expressed
 * in the base units of a unit registry.
 */
void convertPropertyTreeUnits(bpt::ptree& config, const UnitRegistry& ureg)
{
  for (auto& it : config) {
    auto val = it.second.get_value_optional<std::string>();
    if (val) {
      try {
        auto q = ureg.makeQuantity<double>(val.value());
        it.second.put_value(q.to_base_units().value());
      } catch (...) {
      }
    }
    convertPropertyTreeUnits(it.second, ureg);
  }
}

namespace detail
{
void get_paths_imp(const bpt::ptree&                   tree,
                   std::vector<bpt::ptree::path_type>& paths,
                   bpt::ptree::path_type               current_path)
{
  if (!tree.data().empty()) {
    paths.push_back(current_path);
  }

  for (auto& it : tree) {
    auto path = current_path;
    path /= bpt::ptree::path_type(it.first, current_path.separator());
    get_paths_imp(it.second, paths, path);
  }
}
}  // namespace detail

/**
 * Return a list of all property tree paths that have data.
 */
std::vector<bpt::ptree::path_type> get_paths(const bpt::ptree& tree,
                                             char              delim = '.')
{
  std::vector<bpt::ptree::path_type> paths;
  detail::get_paths_imp(tree, paths, bpt::ptree::path_type(delim));
  return paths;
}

/**
 * Return a flattened version of the property tree.
 * All nodes are a direct child of the root/top of the tree.
 */
bpt::ptree flatten_ptree(const bpt::ptree& tree, char delim = '.')
{
  auto       paths = get_paths(tree, delim);
  bpt::ptree ftree;

  for (auto& p : paths) {
    ftree.push_back(bpt::ptree::value_type(p.dump(), tree.get_child(p).data()));
  }

  return ftree;
}

/**
 * Return an un-flattened version of the property tree. Nodes that contain the
 * delimiter in their name will be split into a node with a child node.
 *
 * @param odelim the output delimiter. the character that will be used to
 * determine the new nesting level of each node.
 * @param idelim the input delimiter. the character that is used to delimit
 * levels in the input tree.
 *
 */
bpt::ptree unflatten_ptree(const bpt::ptree& ftree, char odelim = '.',
                           char idelim = '.')
{
  auto       paths = get_paths(ftree, idelim);
  bpt::ptree tree;

  for (auto& p : paths) {
    auto key = p.dump();
    std::replace(key.begin(), key.end(), idelim, odelim);
    bpt::ptree::path_type newp(key, odelim);
    tree.put_child(newp, bpt::ptree()).put_value(ftree.get_child(p).data());
  }

  return tree;
}

#endif  // include protector
